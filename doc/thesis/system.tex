
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua's type system.
Besides its practical contributions, Typed Lua also has some interesting
contributions to the field of optional type systems for scripting
languages.
They are novel type system features that let Typed Lua cover several Lua idioms
and features, such as refinement of tables, multiple return values,
and optional parameters.

\section{Types}
\label{sec:types}

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
t ::= & & \textsc{first-level types:}\\
& \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; s \rightarrow s & \textit{function types}\\
& | \; \{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \phi(t,t) & \textit{filter types}\\
& | \; \pi_{i}^{x} & \textit{projection types}\\
%\multicolumn{3}{c}{}\\
l ::= & & \textsc{{\small literal types:}}\\
& \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} &\\
%\multicolumn{3}{c}{}\\
b ::= & & \textsc{{\small base types:}}\\
& \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String &\\
%\multicolumn{3}{c}{}\\
k ::= & & \textsc{{\small key types:}}\\
& \;\; l \; | \; b \; | \; \Value &\\
%\multicolumn{3}{c}{}\\
v ::= & & \textsc{{\small value types:}}\\
& \;\; t \; | \; \Const \; t &\\ 
%\multicolumn{3}{c}{}\\
s ::= & & \textsc{second-level types:}\\
& \;\; p & \textit{tuple types}\\
& | \; s \sqcup s & \textit{unions of tuple types}\\
%\multicolumn{3}{c}{}\\
p ::= & & \textsc{{\small tuple types:}}\\
& \;\; \Void & \textit{void type}\\
& | \; t* & \textit{variadic types}\\
& | \; t \times p & \textit{pair types}
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
First-level types represent first-class Lua values and
second-level types represent tuples of values that appear in 
assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types,
filter types, and projection types.
Second-level types include tuple types and unions of tuple types.
Tuple types include the type $\Void$, variadic types, and pair types.
Types are ordered by a subtype relationship that we introduce
in Section \ref{sec:subtyping}, so Lua values may belong to
several distinct types.

Literal types represent the type of literal values.
They can be the boolean values $\False$ and $\True$,
an integer value, a floating point value, or a string value.
We will see that literal types are important in our treatment of
table types as records.

Typed Lua includes four base types: $\Boolean$, $\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that
Lua tags as \texttt{boolean} and \texttt{string} during run-time.
Lua 5.3 introduced two internal representations to the tag \texttt{number}:
\texttt{integer} for integer numbers and \texttt{float} for real numbers.
Lua does automatic promotion of \texttt{integer} values to \texttt{float}
values as needed.
We introduced the base type $\Number$ to represent \texttt{float} values,
and the base type $\Integer$ to represent \texttt{integer} values.
In the next section we will show that $\Integer$ is a subtype of $\Number$.
This allows programmers to keep using \texttt{integer} values where
\texttt{float} values are expected.

The type $\Nil$ is the type of \texttt{nil}, the value that Lua uses for
undefined variables, missing parameters, and missing table keys.

The type $\Value$ is the top type, which represents any Lua value.
In Section \ref{sec:rules} we will show that this type,
along with variadic types, helps the type system to drop extra values
on assignments and function calls, thus preserving the
semantics of Lua in these cases.

Typed Lua uses the type $\Self$ to represent the \emph{receiver}
in object-oriented method definitions and method calls.
As we mentioned in Section \ref{sec:oop}, we need the type
$\Self$ to prevent programs from indexing a method without
calling it with the correct receiver.

Union types $t_{1} \cup t_{2}$ represent types that can hold a value
of two different types.

Function types have the form $s \rightarrow s$ and represent Lua functions,
where $s$ is a second-level type.

Second-level types are either tuple types or unions of tuple types.
Tuple types are tuples of first-level types that can end with
either an empty tuple or with a variadic type.
Typed Lua needs second-level types because tuples are not first-class
values in Lua, only appearing on argument passing, multiple returns,
and multiple assignments.
The type $\Void$ is the type of an empty tuple.
A variadic type $t*$ represents a sequence of values of type $t \cup \Nil$;
it is the type of a vararg expression.
Second-level types include unions of tuples because Lua programs
usually overload the return type of functions to denote error,
as we mentioned in Section \ref{sec:statistics}.
For clarity, we use the symbol $\sqcup$ to represent the union between
two different tuple types.
Note that $\cup$ represents the union between two first-level types,
while $\sqcup$ represents the union between two tuple types.

Back to first-level types, table types represent the various forms
that Lua tables can take.
The syntactical form of table types is $\{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{tag}$,
where each $k_{i}$ represents the type of a table key,
and each $v_{i}$ represents the type of the value that table keys of type $k_{i}$ map to.
Key types can only be literal types, base types, or the top type.
We made this restriction to the type of the keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The type $\Value$ is an option when we need a loose table type.
For instance, $\{\Value:\Value\}_{closed}$ represents the type of a
table in which both indices and values can have any type.
Value types can be any first-level type, and can optionally include
the $\Const$ type to denote immutable values.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types.
The tag \emph{unique} represents tables with no keys that do not
inhabit one of the table's key types, and with no alias.
In particular, the type of the table constructor has this tag.
The tag \emph{open} represents \emph{unique} table types that
have at least one alias.
The tag \emph{closed} represents table types that do not provide
any guarantees about keys with types not listed in the table type.
In particular, in the concrete syntax, type annotations, interface
declarations, and userdata declarations always describe \emph{closed} table types.
In the next sections we explain in more detail why we need
different table types.

Any table type has to be \emph{well-formed}.
Informally, a table type is well-formed if key types do not overlap.
In Section \ref{sec:rules} we formalize the definition of well-formed table types.
We delay the proper formalization of well-formed table types because we use
consistent-subtyping in this formalization.

Recursive types have the form $\mu x.t$,
where $t$ is a first-level type that $x$ represents.
For instance, $\mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed}$
is a type for singly-linked lists of integers.
In Section \ref{sec:alias} we mentioned that we can use the following
interface declaration as an alias to this type:
\begin{verbatim}
    local interface Element
      info:integer
      next:Element?
    end
\end{verbatim}

Typed Lua includes filter types as a way to discriminate the type of local
variables inside conditions.
In Section \ref{sec:rules} we show in more detail how our type system
uses them to formalize the \texttt{type} predicates that we mentioned
in Section \ref{sec:unions}.

Typed Lua includes projection types as a way to project
unions of tuple types into unions of first-level types.
In Section \ref{sec:rules} we show in more detail how our type system
uses them as a mechanism for handling unions of tuple types,
when they appear on the right-hand side of the declaration of local variables,
as we mentioned in Section \ref{sec:unions}.
We also show how this feature allows our type system to constrain
the type of a local variable that depends on the type of another local variable.

Typed Lua includes the dynamic type $\Any$ for allowing programmers
to mix static and dynamic typing.

\section{Subtyping}
\label{sec:subtyping}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We explain the subtyping and consistent-subtyping rules throughout this section.
However, we focus the discussion on the definition of subtyping because,
as we mentioned in Section \ref{sec:gradual}, we can combine the
consistency and subtyping relations to achieve consistent-subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

We present the subtyping rules as a deduction system for the
subtyping relation $\senv \vdash t_{1} \subtype t_{2}$.
The variable $\senv$ is a set of pairs of recursion variables.
We need this set to record the hypotheses that we assume when checking
recursive types.

The subtyping rules for literal types and base types include the rules
for defining that literal types are subtypes of their respective base types,
and that $\Integer$ is subtype of $\Number$:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

Subtyping is reflexive and transitive;
therefore, we could have omitted the rule \textsc{S-INT2}.
More precisely, we could have defined a transitive rule for first-level
types instead of defining specific rules for transitive cases.
For instance, a transitive rule would allow us to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic approach
that is close to the implementation, as this approach allows us to use
subtyping to easily formalize consistent-subtyping.

Our type system includes the top type $\Value$,
so any first-level type is a subtype of $\Value$:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

Many programming languages include a bottom type to represent
an empty value that programmers can use as a default expression,
and we could have used the type $\Nil$ for this role.
However, making $\Nil$ the bottom type would lead to several expressions
that would pass the type checker, but that would fail during run-time
in the presence of a \texttt{nil} value.
Thus, our type system does not have a bottom type, and $\Nil$ is a
subtype only of itself and of $\Value$.

Another type that is only a subtype of itself and of the type $\Value$
is the type $\Self$.

The subtyping rules for union types are standard:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
either $t_{1}$ or $t_{2}$.

The subtyping rule for function types is also standard:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash s_{2} \subtype s_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash s_{1} \rightarrow s_{1} \subtype s_{2} \rightarrow r_{2}}
\end{array}
\]

The rule \textsc{S-FUNCTION} shows that subtyping between
function types is contravariant on the type of the parameter list
and covariant on the return type.
In the previous section we explained why our type system uses
second-level types to represent the type of the parameter list
and the return type.
Now, we explain their subtyping rules.

The type $\Void$ is a subtype of itself and of a variadic type:
\[
\begin{array}{c}
\mylabel{S-VOID}\\
\senv \vdash \Void \subtype t{*}
\end{array}
\]

A variadic type $t{*}$ represents a sequence of values of type
$t \cup \Nil$, and the rule \textsc{S-VOID} handles the case where
a given sequence is empty.

The subtyping rule for pair types is the standard covariant rule:
\[
\begin{array}{c}
\mylabel{S-PAIR}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\]

The subtyping rules for variadic types are not so obvious:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VARARG1}\\
\senv \vdash \Nil{*} \subtype \Void
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VARARG2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}{*} \subtype t_{2}{*}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG3}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2}}
      {\senv \vdash t_{1}{*} \subtype t_{2} \times \Void}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG4}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1} \times \Void \subtype t_{2}{*}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VARARG5}\\
\dfrac{\senv \vdash t_{1}{*} \subtype t_{2} \times \Void \;\;\;
       \senv \vdash t_{1}{*} \subtype s_{2}}
      {\senv \vdash t_{1}{*} \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG6}\\
\dfrac{\senv \vdash t_{1} \times \Void \subtype t_{2}{*} \;\;\;
       \senv \vdash s_{1} \subtype t_{2}{*}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}{*}}
\end{array}
\end{array}
\]

We need six different subtyping rules for variadic types
to handle all the cases where they can appear.
The rule \textsc{S-VARARG1} is a special rule for handling the
case where we give a sequence of $\Nil$ to the empty tuple.
The rule \textsc{S-VARARG2} handles the case where both tuple types end
with variadic types, and shows that $t_{1}{*}$ is a subtype of $t_{2}{*}$
if $t_{1} \cup \Nil$ is a subtype of $t_{2} \cup \Nil$.
This rule explicitly includes $\Nil$ in both sides because otherwise
$\Nil{*}$ would not be a subtype of several other variadic types.
For instance, $\Nil{*}$ would not be subtype of $\Number{*}$,
as $\Nil \not\subtype \Number$.
The other rules handle the cases where only one tuple type ends with a variadic type.
Note that the case where both tuple types end with the type $\Void$ does
not require any special rule.
In the next section we will show that we use these subtyping rules,
along with the types $\Value$ and $\Nil$, to make our type system reflect
the semantics of Lua on discarding extra parameters and
replacing missing parameters.

The subtyping rules for unions of tuple types are similar to the
subtyping rules for unions of first-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION4}\\
\dfrac{\senv \vdash s_{1} \subtype s \;\;\;
       \senv \vdash s_{2} \subtype s}
      {\senv \vdash s_{1} \sqcup s_{2} \subtype s}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION5}\\
\dfrac{\senv \vdash s \subtype s_{1}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION6}\\
\dfrac{\senv \vdash s \subtype s_{2}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\end{array}
\]

Back to the subtyping rules between first-level types,
the subtyping rule between \emph{closed} table types resembles the
standard subtyping rule between records:
\[
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash k_{j} \subtype k_{i}' \;\;\;
       \senv \vdash k_{i}' \subtype k_{j} \;\;\;
       \senv \vdash v_{j} \subtype_{c} v_{i}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{closed} \subtype \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}} \; m \ge n
\end{array}
\]

The rule \textsc{S-TABLE1} allows width subtyping between \emph{closed}
table types, and introduces the auxiliary relation $\subtype_{c}$ to
handle depth subtyping on the type of the values stored in the table fields.
We need an auxiliary relation because the subtyping of the
type of the values stored in the table fields changes according to
the tags of the table types.
We define the relation $\subtype_{c}$ as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2} \;\;\;
       \senv \vdash v_{2} \subtype v_{1}}
      {\senv \vdash v_{1} \subtype_{c} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\end{array}
\]

These rules allow closed table types to have depth subtyping on $\Const$ fields.
The rule \textsc{S-FIELD1} defines that mutable fields are invariant,
while the rule \textsc{S-FIELD2} defines that immutable fields are covariant.
The rule \textsc{S-FIELD3} defines that it is safe to promote fields
from mutable to immutable.
We do not include a rule that allows promoting fields from immutable
to mutable because this would be unsafe due to variance.

There is a limitation on \emph{closed} table types that led us to
introduce \emph{open} and \emph{unique} table types.
If the table constructor had a \emph{closed} table type, then
programmers would not be able to use it to initialize a variable with
a table type that describes a more general type.
For instance,
\begin{verbatim}
    local t:{"x":integer, "y":integer?} = { x = 1, y = 2 }
\end{verbatim}
would not type check, as the type of the table constructor would not
be a subtype of the type in the annotation.
More precisely,
\[
\{``x":1, ``y":2\}_{closed} \not\subtype \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\]

Simply promoting the type of each table value to its supertype would
not overcome this limitation, as it still would give to the table constructor
a closed table type without covariant mutable fields.
Thus, programmers would not be able to use the table constructor to
initialize a variable with a table type that includes an optional field.
Using the previous example,
\begin{align*}
& \{``x":\Integer, ``y":\Integer\}_{closed} \not\subtype \\
& \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\end{align*}

We introduced \emph{unique} table types to avoid this limitation,
as they represent the type of tables with no keys that do not
inhabit one of the table's key types, and with no alias.
In particular, this is the case of the table constructor.
The following subtyping rule defines the subtyping relation among
\emph{unique} table types and \emph{closed} table types:
\[
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\begin{array}{c}
       \forall i \in 1..m \; \forall j \in 1..n \;
       \senv \vdash k_{i} \subtype k_{j}' \to \senv \vdash v_{i} \subtype_{u} v_{j}' \\
       \forall j \in 1..n \; \not\exists i \in 1..m \;
       \senv \vdash k_{i} \subtype k_{j}' \to \senv \vdash \Nil \subtype_{o} v_{j}'
       \end{array}}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}}
\end{array}
\]

The rule \textsc{S-TABLE2} allows width subtyping and covariant keys.
It allows covariant keys because we also want to use \emph{unique}
table types as a way to join table fields that inhabit \emph{closed} table types.
For instance, we want to use the table constructor to initialize
a variable with a table type that describes a hash.

The rule \textsc{S-TABLE2} introduced the auxiliary relations
$\subtype_{u}$ and $\subtype_{o}$.
The first allows depth subtyping on all fields,
while the second allows the omission of optional fields.
We define them as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD7}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} v}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD8}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} \Const \; v}
\end{array}
\end{array}
\]

Using \emph{unique} table types to represent the type of the table
constructor allows our type system to type check the previous example.
More precisely,
\[
\{``x":1, ``y":2\}_{unique} \subtype \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\]

Even though we allow width subtyping between \emph{unique} and \emph{closed}
table types, we do not allow it among \emph{unique} and \emph{open} or
\emph{unique} table types because it would violate our definition of
\emph{unique} and \emph{open} table types:
\[
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\begin{array}{c}
       \forall i \in 1..m \\
       \exists j \in 1..n \;
       \senv \vdash k_{i} \subtype k_{j}' \land \senv \vdash v_{i} \subtype_{u} v_{j}' \\
       \forall j \in 1..n \; \not\exists i \in 1..m \;
       \senv \vdash k_{i} \subtype k_{j}' \to \senv \vdash \Nil \subtype_{o} v_{j}'
       \end{array}}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{open|unique}}
\end{array}
\]

The rules that handle subtyping among \emph{open} table types and
\emph{open} or \emph{closed} table types are similar to the rules
that handle subtyping among \emph{unique} table types and other table types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-TABLE4}\\
\dfrac{\begin{array}{c}
       \forall i \in 1..m \; \forall j \in 1..n \;
       \senv \vdash k_{i} \subtype k_{j}' \to \senv \vdash v_{i} \subtype_{c} v_{j}' \\
       \forall j \in 1..n \; \not\exists i \in 1..m \;
       \senv \vdash k_{i} \subtype k_{j}' \to \senv \vdash \Nil \subtype_{o} v_{j}'
       \end{array}}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TABLE5}\\
\dfrac{\begin{array}{c}
       \forall i \in 1..m \\
       \exists j \in 1..n \;
       \senv \vdash k_{i} \subtype k_{j}' \land \senv \vdash v_{i} \subtype_{c} v_{j}' \\
       \forall j \in 1..n \; \not\exists i \in 1..m \;
       \senv \vdash k_{i} \subtype k_{j}' \to \senv \vdash \Nil \subtype_{o} v_{j}'
       \end{array}}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{open}}
\end{array}
\end{array}
\]

The rule \textsc{S-TABLE4} allows width subtyping, while
the rule \textsc{S-TABLE5} does not allow width subtyping.
Both rules allow joining fields plus omitting optional fields.
Both rules use $\subtype_{c}$ to allow depth on $\Const$ fields only.

In the next section we will show in more detail how our type system
handles \emph{open} and \emph{unique} table types to allow the refinement of
table types.

We use the \emph{Amber rule} \citep{cardelli1986amber} to define
subtyping between recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} also uses the rule \textsc{S-ASSUMPTION}
to check whether $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
Both rules use the set of assumptions $\senv$,
where each assumption is a pair of recursion variables.
The rule \textsc{S-AMBER} extends $\senv$ with the assumption
$x_{1} \subtype x_{2}$ to check whether $t_{1} \subtype t_{2}$.
The rule \textsc{S-ASSUMPTION} allows the rule \textsc{S-AMBER}
to check whether an assumption is valid.

A recursive type may appear inside a first-level type, and our
type system includes subtyping rules to handle subtyping between
recursive types and other first-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNFOLDR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNFOLDL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\end{array}
\]

As an example, the rule \textsc{S-UNFOLDR} allows our type system to
type check the function \texttt{insert} from Section \ref{sec:alias}:
\begin{verbatim}
    local function insert (e:Element?, v:integer):Element
      return { info = v, next = e }
    end
\end{verbatim}
that is, the type checker uses the rule \textsc{S-UNFOLDR} to verify whether
the type of the table constructor is a subtype of \texttt{Element}:
\begin{align*}
\{ & ``info":\Integer, \\
   & ``next":\mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed} \cup \Nil \}_{unique} \subtype \\
& \mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed}
\end{align*}

Filter types are subtypes only of themselves and of $\Value$.
More precisey, a filter type $\phi(t_{1},t_{2})$ is a subtype of
the same filter type $\phi(t_{1},t_{2})$, which shares the same
types $t_{1}$ and $t_{2}$, and it is also a subtype of $\Value$.

Projection types are subtypes only of themselves and of $\Value$.
More precisely, a projection type $\pi_{i}^{x}$ is a subtype of the
same projection type $\pi_{i}^{x}$, which shares the same union of
tuples $x$ and the same index $i$, and it is also a subtype of $\Value$.

The dynamic type $\Any$ is neither the bottom nor the top type,
but a separate type that is subtype only of itself and of $\Value$.

Even though the dynamic type $\Any$ does not interact with subtyping,
it does interact with consistent-subtyping.
We present the consistent-subtyping rules as a deduction system for
the consistent-subtyping relation $\senv \vdash t_{1} \lesssim t_{2}$.
As in the subtyping relation, $\senv$ is also a set of pairs of
recursion variables.
We define the consistent-subtyping rules for the dynamic type $\Any$
as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

If we had set the type $\Any$ as both bottom and top types of our
subtyping relation, then any type $t_{1}$ would be a subtype of
any other type $t_{2}$.
The consequence of this is that all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type $t_{1}$ to $\Any$ and then up-cast
$\Any$ to any other type $t_{2}$.
The rules \textsc{C-ANY1} and \textsc{C-ANY2} are the rules that
allow the dynamic type to interact with other first-level types,
and thus allow dynamically typed code to coexist with statically
typed code.
Because of these two rules, consistent-subtyping cannot be transitive.
These two rules are the only rules that differ between
subtyping and consistent-subtyping, if we implement the subtyping rules
as we do in this section.

In the implementation of Typed Lua we also use consistent-subtyping to
normalize and simplify union types, though we let union types free in
the formalization.
For instance, the union type \texttt{boolean|any} results in the
type \texttt{any}, because \texttt{boolean} is consistent-subtype
of \texttt{any}.
Another example is the union type \texttt{number|nil|1} that
results in the union type \texttt{number|nil}, because
\texttt{1} is consistent-subtype of \texttt{number}.

\section{Typing rules}
\label{sec:rules}

In this section we use a reduced core of Typed Lua to present the
most interesting rules of our type system.
This core limits control flow to if and while statements,
has explicit type annotations, and explicit scope for variables.
It also has explicit method declarations and explicit method calls
instead of treating them as syntactic sugar.
We use this reduced core because it simplifies the presentation
of our type system.
Appendix \ref{app:rules} presents the full set of typing rules.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
\vec{l} = el \; | \;
m \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el \; | \;
e(el)_{s} \; | \;
e{:}n(el)_{s}\\
e ::= & \;\; \mathbf{nil} \; | \;
c \; | \;
{...}_{e} \; | \;
n_{e} \; | \;
e_{1}[e_{2}] \; | \;
{<}t{>} \; n \; | \;
f \; | \;
\{ \} \; | \;
\{ \; \vec{p} \; \} \; | \;
\{ \; {...}_{m} \; \} \; | \;
\{ \; \vec{p},{...}_{m} \; \}\\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
e(el)_{e} \; | \;
e{:}n(el)_{e}\\
l ::= & \;\; n_{l} \; | \;
e_{1}[e_{2}] \; | \;
n[c] \; {<}t{>}\\
c ::= & \;\; \mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string}\\
p ::= & \;\; [e_{1}] = e_{2}\\
el ::= & \;\; \mathbf{nothing} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{e}, me \; | \;
me^{x} \; | \;
\vec{e}, me^{x}\\
me ::= & \;\; e(el)_{m} \; | \;
e{:}n(el)_{m} \; | \;
{...}_{m}\\
m ::= & \;\; \mathbf{fun} \; n_{1}{:}n_{2} \; (){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; ({...}{:}t){:}r \; fb\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; fb \; | \;
\mathbf{fun} \; ({...}{:}t){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
fb ::= & \;\; s \;;\; \mathbf{return} \; el\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are literal constants, $p$ are table fields,
$me$ are expressions with multiple results, $f$ are function declarations,
$m$ are method declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

Our reduced core also splits function application, method application, and
the vararg expression (${...}$) into different syntactic categories.
It uses $e(el)_{s}$ to denote function applications that return no value
because they appear as statements,
$e(el)_{e}$ to denote function applications that return only one value,
and $e(el)_{m}$ to denote function applications that return multiple values.
It uses the same categories for method applications, but only ${...}_{e}$
and ${...}_{m}$, as the vararg expression cannot appear as a statement.

We also include two kinds of type cast in our core language:
the expression ${<}t{>} \;n$ and the left-hand value $n[c] \; {<}t{>}$.
We will show that the first helps allowing safe aliasing between
table types, while the second allows the refinement of table types.
Due to the refinement of table types we also split variable names
into two categories: $n_{e}$ when they appear as expressions and
$n_{l}$ when they appear as left-hand values.

We use three different typing relations to present our typing rules
as a deduction system for these typing relations.
We use the relation $\env_{1}, \penv \vdash s, \env_{2}$ for typing
statements.
This relation means that given the type environment $\env_{1}$
and the projection environment $\penv$,
typing the statement $s$ produces the new type environment $\env_{2}$.
We use the relation $\env_{1}, \penv \vdash e : t, \env_{2}$ for
typing expressions.
This relation means that given the type environment $\env_{1}$
and the projection environment $\penv$,
the expression $e$ has type $t$ and produces the new type environment $\env_{2}$.
We use the relation $\env_{1}, \penv \vdash el : r_{1}, \env_{2}, (x,r_{2})$
for typing expression lists.
This relation means that given type type environment $\env_{1}$
and the projection environment $\penv$,
the expression list $el$ has type $r_{1}$ and produces the new type
environment $\env_{2}$ and produces the pair $(x,r_{2})$.
We need three typing relations because statements do not have types
and expression lists can result in a union of tuple types that
should be introduced in the projection environment.
We use $\env_{1}, \penv \vdash el : r, \env_{2}$ when the expression
list does not result in a union of tuple types.
We need two environments because $\env$ maps variables to types,
while $\penv$ maps projection variables to unions of tuple types.
We use $\env_{1}[n \mapsto t]$ for meaning that we extended the environment
$\env_{1}$ with the variable $n$ that maps to type $t$.
We use $\penv[x \mapsto r]$ for meaning that we extended the environment
$\penv$ with the projection variable $x$ that maps to the union of tuple types $r$.

Lua has multiple assignments, and the rule \textsc{T-ASSIGNMENT} uses
tuple types along with consistent-subtyping to type check this Lua feature:
\[
\begin{array}{c}
\mylabel{T-ASSIGNMENT}\\
\begin{array}{c}
\dfrac{\env_{1}, \penv \vdash el:r_{1}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash \vec{l}:r_{2}, \env_{3} \;\;\;
       r_{1} \lesssim r_{2}}
      {\env_{1}, \penv \vdash \vec{l} = el,\env_{3}}
\end{array}
\end{array}
\]

As an example,
\[
x, y = 1, ``foo"
\]
type checks because
$1 \times ``foo" \times \Nil{*} \lesssim \Integer \times \String \times \Value{*}$,
assuming that $x$ and $y$ are in the environment with
types $\Integer$ and $\String$, respectively.
Our type system uses $\Value{*}$ to drop extra values
and $\Nil{*}$ to replace missing values.
In this example, the rules \textsc{T-LHSLIST} and \textsc{T-EXPLIST2}
are the rules that handle these features.

We define the rule \textsc{T-LHSLIST} as follows:
\[
\begin{array}{c}
\mylabel{T-LHSLIST}\\
\dfrac{\env, \penv \vdash l_{k}:t_{k}, \env_{k} \;\;\;
       \env_{m} = merge(\env_{1}, ..., \env_{n}) \;\;\;
       n = |\;\vec{l}\;|}
      {\env, \penv \vdash \vec{l}:t_{1} \times ... \times t_{n} \times \Value{*}, \env_{m}}
\end{array}
\]

First, this rule uses the same environment $\env$ to type check each
left-hand side value $l_{k}$, as they can perform different changes
in the environment.
Then, it takes each type $t_{k}$ and builds the tuple type for
the assignment rule.
It places the type $\Value{*}$ in the end to discard extra values.
The rule succeeds if the predicate \emph{merge} can
produce a new environment, which includes all the modifications
of each environment $\env_{k}$.
Intuitively, the predicate \emph{merge} fails when an environment
tries to change the type of a variable towards a type that is not
a subtype of its previous type.
We will show in this section that the refinement of table types can
change the environment, and that is the reason why we need to check
whether the environment is consistent.

The rule \textsc{T-EXPLIST2} is close to the rule \textsc{T-LHSLIST}.
The difference is that it uses $\Nil{*}$ to replace missing values.
We define this rule as follows:
\[
\begin{array}{c}
\mylabel{T-EXPLIST2}\\
\dfrac{\env, \penv \vdash e_{k}:t_{k}, \env_{k} \;\;\;
       \env_{m} = merge(\env_{1}, ..., \env_{n}) \;\;\;
       n = |\;\vec{e}\;|}
      {\env, \penv \vdash \vec{e}:t_{1} \times ... \times t_{n} \times \Nil{*}, \env_{m}}
\end{array}
\]

The typing rules that type check expression lists include $\Nil{*}$
in the end of the tuple type only when it does not end in a variadic type.
For instance, the rules \textsc{T-EXPLIST3} and \textsc{T-EXPLIST4}
handle the case that an expression list is just an expression that
return multiple values, but only \textsc{T-EXPLIST3} needs to add
$\Nil{*}$:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-EXPLIST3}\\
\dfrac{\env, \penv \vdash me:t_{1} \times ... \times t_{n} \times \Void, \env_{1}}
      {\env, \penv \vdash me:t_{1} \times ... \times t_{n} \times \Nil{*}, \env_{1}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-EXPLIST4}\\
\dfrac{\env, \penv \vdash me:t_{1} \times ... \times t_{n}{*}, \env_{1}}
      {\env, \penv \vdash me:t_{1} \times ... \times t_{n}{*}, \env_{1}}
\end{array}
\end{array}
\]

As an example, the rule \textsc{T-EXPLIST3} allows our type system
to type check the following example:
\[
x, y, z = f()_{m}
\]

In this example, we are assuming that $x$, $y$, $z$, and $f$ are in
the environment with types $\Integer$, $\String$, $\String \cup \Nil$, and
$\Void \rightarrow \Integer \times \String \times \Void$, respectively.
Thus, the example type checks because
\[
\Integer \times \String \times \Nil{*} \lesssim \Integer \times \String \times \String \cup \Nil \times \Value{*}
\]

Conversely,
\[
x = f()_{m}
\]
type checks because
\[
\Integer \times \String \times \Nil{*} \lesssim \Integer \times \Value{*}
\]

Multiple assignments also appear in function applications.
The rule \textsc{T-APPLY1} handles the case where function applications
are expressions that return multiple values:
\[
\begin{array}{c}
\mylabel{T-APPLY1}\\
\dfrac{\env_{1}, \penv \vdash e:r_{1} \rightarrow r_{2}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash el:r_{3}, \env_{3} \;\;\;
       r_{3} \lesssim r_{1}}
      {\env_{1}, \penv \vdash e(el)_{m}:r_{2}, \env_{3}}
\end{array}
\]

We also use the rule \textsc{T-APPLY1} as the base case for the rules
that handle the cases where function applications are either statements
or expressions that return only one value:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-STMAPPLY1}\\
\dfrac{\env_{1}, \penv \vdash e(el)_{m}:r, \env_{2}}
      {\env_{1}, \penv \vdash e(el)_{s},\env_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-EXPAPPLY1}\\
\dfrac{\env_{1}, \penv \vdash e(el)_{m}:r, \env_{2}}
      {\env_{1}, \penv \vdash e(el)_{e}:first(r), \env_{2}}
\end{array}
\end{array}
\]

The rule \textsc{T-STMAPPLY1} discards the returned values,
while the rule \textsc{T-EXPAPPLY1} uses the predicate \emph{first} to
ensure that only one value is returned.
We can use pattern matching to the define the recursive predicate
\emph{first} as follows:
\begin{align*}
first(\Void) & = \Nil\\
first(t{*}) & = t \cup \Nil\\
first(t \times s) & = t\\
first(s_{1} \sqcup s_{2}) & = first(s_{1}) \cup first(s_{2})
\end{align*}

Assuming that $f$ is a local function in the environment, and that $f$ has type
$\String \times \Integer \cup \Nil \times \Integer \cup \Nil \times \Value{*} \rightarrow \Integer{*}$,
the function call
\[
f(``foo")_{s}
\]
type checks through the rules \textsc{T-STMAPPLY1} and \textsc{T-APPLY1}, because
\[
``foo" \times \Nil{*} \lesssim \String \times \Integer \cup \Nil \times \Integer \cup \Nil \times \Value{*}
\]
and the function call
\[
x = f(``foo",1,2,3)_{m}
\]
also type checks through the rules \textsc{T-STMAPPLY1} and \textsc{T-APPLY1}, because
\[
``foo" \times 1 \times 2 \times 3 \times \Nil{*} \lesssim \String \times \Integer \cup \Nil \times \Integer \cup \Nil \times \Value{*}
\]

Our type system also catches arity mismatch.
For instance, assuming that $f$ has type
$\String \times \Integer \cup \Nil \times \Integer \cup \Nil \times \Void \rightarrow \Integer{*}$,
the function call
\[
f(``foo")_{s}
\]
type checks through the rules \textsc{T-STMAPPLY1} and \textsc{T-APPLY1}, because
\[
``foo" \times \Nil{*} \lesssim \String \times \Integer \cup \Nil \times \Integer \cup \Nil \times \Void
\]
but the function call
\[
x = f(``foo",1,2,3)_{m}
\]
does not type check through the rules \textsc{T-STMAPPLY1} and \textsc{T-APPLY1}, because
\[
``foo" \times 1 \times 2 \times 3 \times \Nil{*} \not\lesssim \String \times \Integer \cup \Nil \times \Integer \cup \Nil \times \Void
\]

When our type system type checks an expression list,
it always include $\Nil{*}$ in the end of the type of this expression list,
if the type does not end in a variadic type.
Our type system has this behavior because $\Nil{*}$ along with subtyping
and consistent-subtyping use $\Nil$ to replace missing values.
This behavior preserves the semantics of Lua on replacing missing values,
as it is necessary when we omit optional parameters in a function call,
like the previous example showed.

Using $\Nil{*}$ in the end of the type of expression lists also allows
our type system to catch arity mismatch in function calls where
the type of the function does not include optional parameters.
For instance, assuming that $f$ has type
$\Integer \times \Integer \times \Void \rightarrow \Integer \times \Void$,
the function call
\[
f(1)_{s}
\]
does not type check through the rules \textsc{T-STMAPPLY1} and \textsc{T-APPLY1}, because
\[
1 \times \Nil{*} \not\lesssim \Integer \times \Integer \times \Void
\]
and the function call
\[
x = f(1,2,3)_{m}
\]
also does not type check through the rules \textsc{T-STMAPPLY1} and \textsc{T-APPLY1}, because
\[
1 \times 2 \times 3 \times \Nil{*} \not\lesssim \Integer \times \Integer \times \Void
\]

The same behavior happens with the rule that type checks the \textbf{return}
statement:
\[
\begin{array}{c}
\mylabel{T-RETURN}\\
\dfrac{\env_{1}, \penv \vdash el:r_{1}, \env_{2} \;\;\;
       \env_{2}(\ret) = r_{2} \;\;\;
       r_{1} \lesssim r_{2}}
      {\env_{1}, \penv \vdash \mathbf{return} \; el,\env_{2}}
\end{array}
\]

Now, we move the discussion to the rules that type check the
different table constructors that our abstract syntax includes,
as they will appear in the next examples:

The simplest form of the table constructor is the empty table $\{\}$.
Its rule is straightforward:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR1}\\
\env, \penv \vdash \{\}:\{\}_{unique}, \env
\end{array}
\]

Our abstract syntax reduces the more complex uses of the table
constructor into three forms: $\{\;\vec{p}\;\}$, $\{\;{...}_{m}\;\}$,
and $\{\;\vec{p},{...}_{m}\;\}$.
The first one uses a list of table fields $[e_{1}] = e_{2}$,
the second one uses just the vararg expression, and the third one uses both.
We did not include in the abstract syntax a table constructor
that uses a list of expressions, because we can write it using the first form.
For instance, we can write the table constructor
$\{ [1] = ``x", [2] = ``y", [3] = ``z" \}$ to express $\{ ``x", ``y", ``z" \}$.
We chose to not include the latter form because its type checking rule is similar
to the type checking rule of the first form, and it just controls the type of
the omitted indices.
For the same reason, we did not include table constructors with
multiple expressions, which can return a tuple type that does not end
with a variadic type.
We did include the vararg expression in the last position to show how
our type system can type check a table type that has a record part and
also an array part.

The rule \textsc{T-CONSTRUCTOR2} type checks a table type of the first form:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR2}\\
\dfrac{\env_{i}, \penv \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       t = wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique})}
      {\env_{1}, \penv \vdash \{\;\vec{p}\;\}:t, \env_{n+1}}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR2} type checks each table field $p_{i}$,
uses the type of the table fields to build the table type, and
uses the predicate \emph{wf} to check whether the table type is
well formed.
Formally, a table type is well-formed if it obeys the following rule:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

Well-formed table types avoid ambiguous table types.
For instance, this rule detects that the table type
$\{1:\Number, \Integer:\String, \Any:\Boolean\}$ is ambiguous,
because the type of the value stored by key $1$ can be
$\Number$, $\String$, or $\Boolean$, as $1 \lesssim 1$,
$1 \lesssim \Integer$, and $1 \lesssim \Any$.
Moreover, the type of the value stored by a key of type $\Integer$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Integer \lesssim \Integer$, and $\Integer \lesssim \Any$.

The type checking of the table fields would be straightforward
if our table types allowed any first-level type in the type of the keys.
The rules \textsc{T-FIELD1}, \textsc{T-FIELD2}, and \textsc{T-FIELD3}
check if the type of the key is a subtype of $\Boolean$, $\Number$,
or $\String$, respectively:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-FIELD1}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Boolean}
      {\env_{1}, \penv \vdash [e_{1}] = e_{2}: t_{1}{:}close(t_{2}), \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-FIELD2}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Number}
      {\env_{1}, \penv \vdash [e_{1}] = e_{2}: t_{1}{:}close(t_{2}), \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-FIELD3}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \String}
      {\env_{1}, \penv \vdash [e_{1}] = e_{2}: t_{1}{:}close(t_{2}), \env_{3}}
\end{array}
\end{array}
\]

These rules use the predicate \emph{close} in the type of the value
because our type system do not allow \emph{open} and \emph{unique}
table types to appear in the type of the values.
The predicate \emph{close} promotes all table types to \emph{closed}.
We made this restriction because our type system does not keep track
of aliases to table fields.
This means that allowing \emph{open} and \emph{unique} table types
to appear in the type of the values would allow the creation of
unsafe aliases.

The rule \textsc{T-FIELD4} is a fallback for the previous rules:
\[
\begin{array}{c}
\mylabel{T-FIELD4}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t_{2}, \env_{3}}
      {\env_{1}, \penv \vdash [e_{1}] = e_{2}: \Value{:}close(t_{2}), \env_{3}}
\end{array}
\]

The rule \textsc{T-FIELD4} shows that our type system uses the type $\Value$
as the type of the key whenever a key has a type that is neither a
subtype of $\Boolean$, nor a subtype of $\Number$, nor a subtype of $\String$.

As an example, the table constructor $\{[``x"] = 1, [``y"] = \{[``z"] = 2\}\}$
has type $\{``x":1, ``y":\{``z":2\}_{closed}\}_{unique}$ through the rules
\textsc{T-FIELD3} and \textsc{T-CONSTRUCTOR2}.

Typed Lua handles arrays as hashes that map integers to some type $t$.
In Lua, programmers often use the vararg expression to initialize arrays.
The rules \textsc{T-CONSTRUCTOR3} and \textsc{T-CONSTRUCTOR4} define
the behavior of the vararg expression for this case:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-CONSTRUCTOR3}\\
\dfrac{\env_{1}({...}) = t}
      {\env_{1}, \penv \vdash \{{...}_{m}\}:\{\Integer{:}t \cup \Nil\}_{unique}, \env_{1}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-CONSTRUCTOR4}\\
\dfrac{\begin{array}{c}
       \env_{i}, \penv \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       \env_{i+1}({...}) = t_{v}\\
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, \Integer{:}t_{v} \cup \Nil\}_{unique}) = t_{t}
       \end{array}}
      {\env_{1}, \penv \vdash \{\;\vec{p},\;{...}_{m}\;\}:t_{t}, \env_{n+1}}
\end{array}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR3} type checks the case where we use
only the vararg expression inside a table constructor to initialize
an array.
If we assume that $...$ is in the environment and has type $\String$,
the table constructor $\{{...}_{m}\}$ has type $\{\Integer:\String \cup \Nil\}_{unique}$
through the rule \textsc{T-CONSTRUCTOR3}.

The rule \textsc{T-CONSTRUCTOR4} type checks the case where we use
the table constructor as a record that includes an array part.
If we assume that $...$ is in the environment and has type $\String$,
the table constructor $\{[``x"] = ``foo", [``y"] = \mathbf{true}, {...}_{m}\}$
has type $\{``x":``foo", ``y":\mathbf{true}, \Integer:\String \cup \Nil\}_{unique}$
through the rule \textsc{T-CONSTRUCTOR4}.
As another example, the rule \textsc{T-CONSTRUCTOR4} does not type check
the table constructor $\{ [1] = ``foo", [10] = \mathbf{true}, {...}_{m} \}$,
because the keys $1$ and $10$ overlap the array part.

After discussing the typing rules of the table constructor,
we start the discussion of the rules that define the most
unusual feature of our type system: the refinement of table types.
The rule \textsc{T-REFINE} allows adding new keys to \emph{open}
and \emph{unique} table types:
\[
\begin{array}{c}
\mylabel{T-REFINE}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{open|unique}\\
       \env_{1}, \penv \vdash c:k_{n+1}, \env_{2} \;\;\;
       \not \exists i \in 1..n \; t_{1} \lesssim k_{i} \;\;\;
       v_{n+1} = close(t)
       \end{array}}
      {\env_{1}, \penv \vdash n[c] {<}t{>}:t, \env_{2}[n \mapsto \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, k_{n+1}{:}v_{n+1}\}_{open|unique}]}
\end{array}
\]

We restricted the refinement of table types to include only literal
keys, because its purpose is to make it easier the construction of
table types that represent records.

We use the refinement of table types to handle global variables.
In Lua, the assignment \texttt{v = v + 1} translates to
\texttt{\string_ENV["v"] = \string_ENV["v"] + 1} when \texttt{v}
is not a local variable, where \texttt{\string_ENV} is a table
that stores the global environment.
For this reason, Typed Lua treats accesses to global variables as field accesses
to an open table in the top-level scope.
For instance,
\[
\string_ENV[``x"] \; {<}\String{>} = ``foo" \;;\; \string_ENV[``y"] \; {<}\Integer{>} = 1
\]
uses field assignment to add fields $``x"$ and $``y"$ to $\string_ENV$.
In this example and in the next examples we assume that
$\string_ENV$ is in the environment and has type $\{\}_{open}$.
Therefore, after these field assignments $\string_ENV$ has type
$\{``x":\String, ``y":\Integer\}_{open}$.

We do not allow the refinement of table types to change the type of
a field that is already present in the table type.
For instance,
\[
\string_ENV[``x"] \; {<}\String{>} = ``foo" \;;\; \string_ENV[``x"] \; {<}\Integer{>} = 1
\]
do not type check, as we are trying to add a field that already exists
in $\string_ENV$.
We could have used union types to allow the refinement of existing fields,
but this could lead to fields that have a too general type, which could
decrease the amount of static type checking.
This means that our type system does not allow the table type to change
towards a type that is not a subtype of the previous type.
In this example,
\[
\{``x":\String \cup \Integer\}_{open} \not\subtype \{``x":\String\}_{open}
\]

We also do not allow the refinement of table types to introduce
\emph{open} or \emph{unique} table fields.
For instance,
\begin{center}
\begin{tabular}{l}
$\string_ENV[``x"] \; {<}\{\}_{unique}{>} = \{\}$
\end{tabular}
\end{center}
refines the type of $\string_ENV$ from $\{\}_{open}$ to $\{``x":\{\}_{closed}\}_{open}$,
though we are trying to refine to $\{``x":\{\}_{unique}\}_{open}$.
As in the type of the table constructor, the refinement of
table types also does not allow the inclusion of values that
have \emph{open} and \emph{unique} table types.

We can also use multiple assignments to refine table types:
\[
\string_ENV[``x"] \; {<}\String{>}, \string_ENV[``y"] \; {<}\Integer{>} = ``foo", 1
\]

This example type checks because all the environment changes are consistent, and
$``foo" \times 1 \times \Nil{*} \lesssim \String \times \Integer \times \Value{*}$.

However, the next example does not type check because it tries to add
the same field to $\string_ENV$, but with different types:
\[
\string_ENV[``x"] \; {<}\String{>}, \string_ENV[``x"] \; {<}\Integer{>} = ``foo", 1
\]

Besides allowing the refinement of table types through field assignment,
Typed Lua also keeps track whether it is safe to change the type of a table.
For instance,
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{``foo":\Integer\}_{unique} = \{ [``foo"] = 5 \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``foo":\Integer \cup \Nil \}_{closed} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$b[``foo"] = \mathbf{nil}$}
\end{tabular}
\end{center}
does not type check, as aliasing $a$ produces the type
$\{``foo":\Integer\}_{closed}$ that is not a subtype of
$\{``foo":\Integer \cup \Nil\}_{closed}$, the type of $b$.
The rule \textsc{T-IDREAD} defines this behavior:
\[
\begin{array}{c}
\mylabel{T-IDREAD}\\
\dfrac{\env_{1}(n) = t}
      {\env_{1}, \penv \vdash n_{e}:close(t), \env_{1}[n \mapsto open(t)]}
\end{array}
\]

Aliasing \emph{unique} and \emph{open} table types can be unsafe.
For this reason, the rule \textsc{T-IDREAD} promote the type of an
alias expression from \emph{unique} or \emph{open} to \emph{closed},
and it also promotes the aliased variable from
\emph{unique} to \emph{open}, as \emph{unique} table types only
denote the type of tables with no alias.

As another example,
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
does not type check, as aliasing $a$ produces the type $\{\}_{closed}$
that is not a subtype of $\{\}_{open}$, the type of $b$.
Our type system has this behavior to warn programmers about
potential unsafe behaviors after this kind of alias.
In this example, it is unsafe to add the field $``x"$ to $b$,
as it changes the value that is stored in the field $``x"$ of local $a$.

We also need to close \emph{unique} and \emph{open} tables that
appear in the left-hand side of assignments.
For instance,
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = \{\} \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$b = a;$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
does not type check because we cannot add the field $``x"$ to $b$,
as its type is \emph{closed}, and thus does not allow changing the
value that is stored in the field $``x"$ of local $a$.
The rule \textsc{T-IDWRITE} defines this behavior:
\[
\begin{array}{c}
\mylabel{T-IDWRITE}\\
\dfrac{\env_{1}(n) = t}
      {\env_{1}, \penv \vdash n_{l}:close(t), \env_{1}[n \mapsto close(t)]}
\end{array}
\]

We also have different rules for type checking table indexing to avoid
promoting table types in these operations:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-INDEX1}\\
\dfrac{\env_{1}(n) = \{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\} \;\;\;
       \env_{1}, \penv \vdash e_{2}:t, \env_{2} \;\;\;
       \exists i \in 1{..}n \; t \lesssim k_{i}}
      {\env_{1}, \penv \vdash n[e_{2}]:v_{i}, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-INDEX2}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t, \env_{3} \;\;\;
       \exists i \in 1{..}n \; t \lesssim k_{i}}
      {\env_{1}, \penv \vdash e_{1}[e_{2}]:v_{i}, \env_{3}}
\end{array}
\end{array}
\]

Sometimes we want to use a local variable that holds an \emph{unique}
table type to initialize a \emph{closed} table type, as \emph{unique}
table types allow us to initialize optional fields.
To do that, Typed Lua includes a cast expression that allows us
to use an \emph{unique} table type before it becomes \emph{open}.
The rule \textsc{T-CAST} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-CAST}\\
\dfrac{\env_{1}(n) \subtype t \;\;\;
       \env_{1}[n \mapsto t], \penv \vdash n_{e}:t_{1}, \env_{2}}
      {\env_{1}, \penv \vdash {<}t{>} \; n:t_{1}, \env_{2}}
\end{array}
\]

The rule \textsc{T-CAST} allows our type system to type check the following example:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{ \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{2}{l}{$a[``y"] \; {<}\String{>} = ``bar";$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String, ``y":\String \cup \Nil \}_{closed} =$}\\
& & \multicolumn{1}{l}{${<}\{``x":\String, ``y":\String \cup \Nil\}_{open}{>} \; a \; \mathbf{in} \; a[``z"] \; {<}\Integer{>} = 1$}
\end{tabular}
\end{center}

We can use $a$ to initialize $b$ because the cast expression converts
the type of $a$ from $\{``x":\String, ``y":\String\}_{unique}$ to
$\{``x":\String, ``y":\String \cup \Nil\}_{open}$, and results in
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$.
We can continue to refine the type of $a$ after the aliasing,
as it still holds an \emph{open} table.
At the end of this example, $a$ has type
$\{``x":\String, ``y":\String \cup \Nil, ``z":\Integer\}_{open}$.

We also need to make sure to close all \emph{unique} and \emph{open}
table types before we type check another scope.
The rule \textsc{T-FUNCTION3} illustrates this case:
\[
\begin{array}{c}
\mylabel{T-FUNCTION3}\\
\dfrac{closeall(\env_{1}[\vec{n} \mapsto \vec{t}, \ret \mapsto r]), \penv \vdash s, \env_{2}}
      {\env_{1}, \penv \vdash \mathbf{fun} \; (\vec{n{:}t}){:}r \; s:\vec{t} \rightarrow r, closeset(\env_{1}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))}
\end{array}
\]

The rule \textsc{T-FUNCTION3} uses the predicates \emph{closeall}
and \emph{closeset} to close \emph{open} and \emph{unique} table types.
The predicate \emph{closeall} closes all \emph{open} and \emph{unique}
table types before type checking another scope.
The predicate \emph{closeset} closes a given set of free assigned variables,
which is given by the predicate \emph{fav}.
This rule prevents the following unsafe example to type check:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{local} \; b:\Integer \times \Integer \times \Void \rightarrow \Integer \times \Void =$}\\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$}\\
& & & \multicolumn{1}{l}{$a[``z"] \; {<}\Integer{>} = 1; \; \mathbf{return} \; x + y$}\\
& \multicolumn{3}{l}{$\mathbf{in} \; a[``z"] \; {<}\String{>} = ``foo"$}
\end{tabular}
\end{center}

Typed Lua also uses the refinement of table types to type check
common idioms that Lua programmers use for building modules and objects.
For instance, the rule \textsc{T-METHOD3} illustrates how our type system
type checks method definitions:
\[
\begin{array}{c}
\mylabel{T-METHOD3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n_{1}) = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{unique|open} \;\;\;
       \env_{1}, \penv \vdash n_{2} : l \;\;\;
       \not \exists i \in 1..n \; l \lesssim k_{i}\\
       closeall(\env_{1}[self \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed}, \vec{n} \mapsto \vec{t}, \ret \mapsto r]), \penv \vdash s, \env_{2}\\
       t_{m} = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}, l{:}\Const \; \Self \times \vec{t} \rightarrow r\}_{unique|open}
       \end{array}}
      {\begin{array}{c}
       \env_{1}, \penv \vdash \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; s,\\
       closeset(\env_{1}[n_{1} \mapsto t_{m}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))
       \end{array}}
\end{array}
\]

The rule \textsc{T-METHOD3} allows our type system to type check the
following example, which is a translation of the definition of the class
\texttt{Shape} from Section \ref{sec:oop}:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{open} = \{ [``x"] = 0.0, [``y"] = 0.0 \}$}\\
\multicolumn{4}{l}{$\mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; s{:}new (x:\Number, y:\Number):\Self \times \Void$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{closed} =$}\\
& & & \multicolumn{1}{l}{$setmetatable(\{\}, \{ [``\string_\string_index"] = self \})$}\\
& & \multicolumn{2}{l}{$\mathbf{in} \; s[``x"] = x; \; s[``y"] = y; \; \mathbf{return} \; s$}\\
; & \multicolumn{3}{l}{$\mathbf{fun} \; s{:}move (x:\Number, y:\Number):\Void$}\\
& & \multicolumn{2}{l}{$self[``x"] = self[``x"] + x;$}\\
& & \multicolumn{2}{l}{$self[``y"] = self[``y"] + y$}
\end{tabular}
\end{center}

This example uses the type $\{``x":\Number, ``y":\Number\}_{open}$ to
initialize the local variable $s$, which represents the type of the class
that we are defining.
Then, we use two method definitions to include $new$ and $move$ into
our class that now has type
\begin{align*}
\{ & ``x":\Number, ``y":\Number,\\
   & \Const \; ``new":\Self \times \Number \times \Number \rightarrow \Self,\\
   & \Const \; ``move":\Self \times \Number \times \Number \rightarrow \Void \}_{open}
\end{align*}

Inside the definition of the method \emph{new} we use \emph{setmetatable}
to initialize the local $s$ with the type of $\Self$.
The rule \textsc{T-SETMETATABLE1} express this idea:
\[
\begin{array}{c}
\mylabel{T-SETMETATABLE1}\\
\dfrac{\env_{1}, \penv \vdash e:t, \env_{2} \;\;\;
       t \subtype \{\}_{open}}
      {\env_{1}, \penv \vdash setmetatable(\{\}, \{[``\string_\string_index"] = e\}):close(t), \env_{2}}
\end{array}
\]

After we define our class, we can use it to create object instances
of this class and call its methods.
The rule \textsc{T-INVOKE1} handles the case where method calls
are expressions that return multiple values:
\[
\begin{array}{c}
\mylabel{T-INVOKE1}\\
\dfrac{\env_{1}, \penv \vdash e:t, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e[n]:p_{1} \rightarrow r, \env_{3} \;\;\;
       \env_{3}, \penv \vdash el:p_{2}, \env_{4} \;\;\;
       \Self \times p_{2} \lesssim p_{1}}
      {\env_{1}, \penv \vdash e{:}n(el)_{m}:[\Self \mapsto t]r, \env_{4}}
\end{array}
\]

We also use the rule \textsc{T-INVOKE1} as the base case for the rules
that handle the cases where method calls are either statements
or expressions that return only one value:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-STMINVOKE1}\\
\dfrac{\env_{1}, \penv \vdash e{:}n(el)_{m}:r, \env_{2}}
      {\env_{1}, \penv \vdash e{:}n(el)_{s},\env_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-EXPINVOKE1}\\
\dfrac{\env_{1}, \penv \vdash e{:}n(el)_{m}:r, \env_{2}}
      {\env_{1}, \penv \vdash e{:}n(el)_{e}:first(r), \env_{2}}
\end{array}
\end{array}
\]

The rule \textsc{T-STMINVOKE1} discards the returned values,
while the rule \textsc{T-EXPINVOKE1} uses the predicate \emph{first} to
ensure that only one value is returned.

As an example, assuming that the object $o$ is in the environment and
has the type of the class from the previous example, the method call
\[
o{:}move(10, 10)_{s}
\]
type checks through the rules \textsc{T-STMINVOKE1} and \textsc{T-INVOKE1},
because
\[
\Self \times 10 \times 10 \times \Nil{*} \lesssim \Self \times \Number \times \Number \times \Void
\]

Typed Lua includes five typing rules for handling the $\mathbf{or}$
logical operator and its common idioms:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR1}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t, \env_{2} \;\;\;
       \Nil \not\lesssim t \;\;\;
       \False \not\lesssim t}
      {\env_{1}, \penv \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR2}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:\Nil, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t, \env_{3}}
      {\env_{1}, \penv \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-OR3}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:\False, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t, \env_{3}}
      {\env_{1}, \penv \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:\Nil \cup \False, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t, \env_{3}}
      {\env_{1}, \penv \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR5}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t_{2}, \env_{3}}
      {\env_{1}, \penv \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-OR1} is the rule that defines the short circuit.
We use the consistent-subtyping relation in this rule to guarantee that
the type system checks the second expression when the first one
has the dynamic type, as it can be hiding a false value.

The rules \textsc{T-OR2}, \textsc{T-OR3}, and \textsc{T-OR4} guarantee
that the final result is the type of the second expression, because the
first one is certainly a false value.

The rule \textsc{T-OR5} is the most general rule, but it is also
the rule that handles the common $\mathbf{or}$ idioms.
It uses the predicate \emph{filter} to filter possible false values
that might be part of the type of the first expression.
We can use pattern matching to the define the recursive predicate
\emph{filter} as follows:
\begin{align*}
filter(t_{1} \cup t_{2}, t_{1}) & = filter(t_{2}, t_{1})\\
filter(t_{1} \cup t_{2}, t_{2}) & = filter(t_{1}, t_{2})\\
filter(t_{1} \cup t_{2}, t_{3}) & = filter(t_{1}, t_{3}) \cup filter(t_{2}, t_{3})\\
filter(t_{1}, t_{2}) & = t_{1}
\end{align*}

The rule \textsc{T-OR5} allows our type system to type check the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\String \cup \Nil = \mathbf{nothing} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

Without the \emph{filter} predicate,
the expression $x \; \mathbf{or} \; ``Hello"$ would have type
$\String \cup \Nil \cup ``Hello"$.
The \emph{filter} predicate removes the type $\Nil$ from the result,
leaving the type $\String \cup ``Hello"$.
At the end of the type checking, the expression $x \; \mathbf{or} \; ``Hello"$
has type $\String$ because union types are disjoint and $``Hello" \subtype \String$.

Another common idiom that programmers use in Lua is to overload
the input parameter of functions, and use the function \texttt{type}
to execute different actions according to their types.
The rule \textsc{T-IF2} shows the case where our type system
discriminates the type of a local variable base on the tag \texttt{string}:
\[
\begin{array}{c}
\mylabel{T-IF2}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = t\\
       closeall(\env_{1}[n \mapsto \phi(t,\String)]), \penv \vdash s_{1}, \env_{2} \\
       closeall(\env_{1}[n \mapsto \phi(t,filter(t, \String))), \penv \vdash s_{2}, \env_{3}\\
       \env_{4} = closeset(\env_{1}[n \mapsto t], fav(s_{1}) \cup fav(s_{2}))
      \end{array}}
      {\env_{1}, \penv \vdash \mathbf{if} \; type(n) == ``string" \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}, \env_{4}}

\end{array}
\]

In Typed Lua, \emph{type} is a primitive that triggers a type change.
In the rule \textsc{T-IF2}, the type of the variable $n$ changes from
$t$ to $\phi(t,\String)$ inside the $\mathbf{if}$ branch, and it changes
the type of the variable $n$ from $t$ to $\phi(t,filter(t,\String))$
inside the $\mathbf{else}$ branch.
Our type system changes the type of a local variable to a filter type
because it gives the discriminated type when we use the variable as
an expression, and it restores the original type when we use the variable
in an assignment.
We will use the following example to discuss how our type system uses
the rule \textsc{T-IF2} to type check this given example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; o:\String \times \String \cup \Integer \times \Void \rightarrow \String \times \Void =$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; (a:\String, b:\String \cup \Integer):\String \times \Void$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; r:\String = ``" \; \mathbf{in}$}\\
& & & \multicolumn{1}{l}{$\mathbf{if} \; type(b) == ``string" \; \mathbf{then} \; r = a \;{..}\;b \; \mathbf{else} \; r = rep(a, b)_{e}\; ;$}\\
& & & \multicolumn{1}{l}{$\mathbf{return} \; r$}\\
\multicolumn{4}{l}{$\mathbf{in} \; o(``foo", 2)_{s}$}
\end{tabular}
\end{center}

In this example, we are assuming that the function \emph{rep} is in
the environment and has type
$\String \times \Integer \times \String \cup \Nil \times \Void \rightarrow \String \times \Void$.
Note that rule \textsc{T-IF2} changes the type of $b$ to
$\phi(\String \cup \Integer, \String)$ inside the $\mathbf{if}$ branch,
and it changes the type of $b$ to
$\phi(\String \cup \Integer, \Integer)$ inside the $\mathbf{else}$ branch.
This example type checks because reading $b$ results in the type
$\String$ inside the $\mathbf{if}$ branch, and it results in the type
$\Integer$ inside the $\mathbf{else}$ branch.
Outside the condition, the local variable $b$ has type $\String \cup \Integer$.

Typed Lua also includes similar rules to handle the tags \texttt{nil},
\texttt{boolean}, and \texttt{number}.
There is also a similar rule for handling the tag \texttt{integer}, but
it is limited to Lua 5.3, as it depends on the function \texttt{math.type}.
This function appears only in Lua 5.3 and it returns the string $``integer"$
when its input parameter is a number that has an integer representation,
the string $``float"$ when its input parameter is a number that has a
floating point representation, or $\Nil$ otherwise.

Lua programmers also overload the return type of functions to denote errors,
and our type system also handles this idiom.
For instance,
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; q:\pi_{1}^{x}, r:\pi_{2}^{x} = idiv(1, 2)_{m}^{x} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{if} \; q \; \mathbf{then} \; print(q + r)_{s} \; \mathbf{else} \; print(``ERROR: " \; .. \; r)_{s}$}
\end{tabular}
\end{center}
type checks, assuming that functions \emph{idiv} and \emph{print} are in
the environment with the respective types
$\Integer \times \Integer \times \Void \rightarrow \Integer \times \Integer \times \Void \sqcup \Nil \times \String \times \Void$
and
$\Value{*} \rightarrow \Void$.
There are three typing rules involved in the type checking of this example,
which we will explain now.

First, type checking $idiv(1, 2)_{m}^{x}$ results in a tuple of projection
types and in a pair that the typing rule of the local declaration needs
for introducing the variable $x$ in the projection environment.
The rule \textsc{T-EXPLIST6} express this intuition:
\[
\begin{array}{c}
\mylabel{T-EXPLIST6}\\
\dfrac{\begin{array}{c}
       \env, \penv \vdash me^{x}:r\\
       r = t_{1} \times ... \times t_{n} \times \Void \sqcup t_{1}' \times ... \times t_{n}' \times \Void, \env_{1}
       \end{array}}
      {\env, \penv \vdash me^{x}:\pi_{1}^{x} \times ... \times \pi_{n}^{x} \times \Nil{*}, \env_{1}, (x,r)}
\end{array}
\]

Then, type checking the local declaration checks whether the tuple of projection
types match the types in the annotations.
If the types match, the local declaration extends the type environment with the
new variables, and it also uses the pair $(x,r)$ from the previous rule to
extend the projection environment before type checking the statements.
The rule \textsc{T-LOCAL} express this intuition:
\[
\begin{array}{c}
\mylabel{T-LOCAL}\\
\dfrac{\env_{1}, \penv \vdash el:r_{1}, \env_{2}, (x,r_{2}) \;\;\;
       r_{1} \lesssim \vec{t} \;\;\;
       \env_{2}[\vec{n} \mapsto \vec{t}], \penv[x \mapsto r_{2}] \vdash s, \env_{3}}
      {\env_{1}, \penv \vdash \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s, \env_{3} - \{\vec{n} \mapsto \vec{t}\}}
\end{array}
\]

After type checking the statement $s$, the rule \textsc{T-LOCAL} produces a
new environment without the variables that it introduced before type checking $s$.

Once the projection is in the environment, our type system can allow
discriminating variables that hold projection types.
The rule \textsc{T-IF3} illustrates the case of our previous example:
\[
\begin{array}{c}
\mylabel{T-IF3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \pi_{i}^{x} \;\;\; \penv(x) = r\\
       closeall(\env_{1}), \penv[x \mapsto fpt(r,\Nil,i)] \vdash s_{1}, \env_{2} \\
       closeall(\env_{1}), \penv[x \mapsto gpt(r,\Nil,i)] \vdash s_{2}, \env_{3}
      \end{array}}
      {\env_{1}, \penv \vdash \mathbf{if} \; n \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}, closeset(\env_{1}, fav(s_{1}) \cup fav(s_{2}))}
\end{array}
\]

The rule \textsc{T-IF3} uses the predicates \emph{fpt} and \emph{gpt}
to filter projections, affecting all variables that bind to the same projection.
For instance, our previous example type checks through the rule \textsc{T-IF3},
because it makes the rule \textsc{T-IF3} use the predicate
\[
fpt(\Integer \times \Integer \times \Void \sqcup \Nil \times \String \times \Void, \Nil, 1)
\]
to discriminate the projection $x$ to the single tuple
$\Integer \times \Integer \times \Void$, and the predicate
\[
gpt(\Integer \times \Integer \times \Void \sqcup \Nil \times \String \times \Void, \Nil, 1)
\]
to discriminate the projection $x$ to the single tuple
$\Nil \times \String \times \Void$.
This means that the type of $q$ ($\pi_{1}^{x}$) and $r$ ($\pi_{2}^{x}$)
project to $\Integer$ and $\Integer$ inside the $\mathbf{if}$ branch,
but they project to $\Nil$ and $\String$ inside the $\mathbf{else}$ branch.
Outside the $\mathbf{if}$ statement, the types of $q$ and $r$ project
to $\Integer \cup \Nil$ and $\Integer \cup \String$, respectively.

Lua has operator overloading, and allows the programmers to redefine
the behavior of some operations.
For instance, programmers can use metatables to redefine the
behavior of arithmetic operations.
Even though Typed Lua does not support operator overloading yet,
it includes typing rules that allow programmers to use the
dynamic type when they are using overloaded operations.
The following typing rules show how Typed Lua uses the dynamic type
to handle the overloading of arithmetic operations:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-ARITH5}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:\Any, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:t, \env_{3}}
      {\env_{1}, \penv \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-ARITH6}\\
\dfrac{\env_{1}, \penv \vdash e_{1}:t, \env_{2} \;\;\;
       \env_{2}, \penv \vdash e_{2}:\Any, \env_{3}}
      {\env_{1}, \penv \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-ARITH5} allows type checking the following
example:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Any = 1 \; \mathbf{in} \; x = x + 1$
\end{tabular}
\end{center}

This example is safe, but the following it is not:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Integer, \;y{:}\Any = 1 \; \mathbf{in} \; x = x + y$
\end{tabular}
\end{center}

Although this last example is not safe, it shows that optional
type systems still preserve the flexibility of dynamically
typed languages along with the benefits of static type checking.
